package org.example;

public class Sass {
    public static void main(String[] args) {
//        int checkMinMax = Integer.MIN_VALUE;
//        int checkMaxMin = Integer.MAX_VALUE;
//        System.out.println(checkMinMax);
//        System.out.println(checkMaxMin );
//
//        float checkMax = Integer.MAX_VALUE;
//        float checkMin = Integer.MIN_VALUE;
//        System.out.println(checkMax);
//        System.out.println(checkMin);
//
//        System.out.println(checkMinMax - 1); //overflow and underflow
//        System.out.println(checkMaxMin + 1);
//
//        int test = checkMaxMin + 1;
//        int rest = checkMinMax - 1;
//        System.out.println(test);
//        System.out.println(rest);
//
//        int tgif = 2147483648; // this would result in an error because compiler evaluates
//        System.out.println(tgif);

//        int zest = 2_000_000;
//        System.out.println(zest);
//
//        System.out.println("Byte range: (" + Byte.MIN_VALUE + " to " + Byte.MAX_VALUE + ")");
//        System.out.println(Long.SIZE);
//
//        byte nana = 56;
//        byte papa = (byte) (nana / 2); //casting
//        System.out.println(papa);
//
//        byte sisi = (56 / 2); //works because although the result is an int (which is the default dt for whole numbers in java, assigning literal numbers, the compiler can compute and knows in should return a short, other scenarios where numeric literals are used, cast!

//        float henry = 5f / 3f;
//        double hen = 5d / 3d;
//        System.out.println(henry); // double value is more precis from output
//        System.out.println(hen);
//        char myFirstUnicode = '\u0044';
//
//        System.out.println(myFirstUnicode);

        int ace = 2;
        ace += 1;
        System.out.println(ace);







    }
}
